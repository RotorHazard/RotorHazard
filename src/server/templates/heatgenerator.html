{% extends "layout-basic.html" %} {% block title %}{% endblock %} {% block head %}
<link rel="stylesheet" href="/static/streetleague.css?{{ serverInfo['release_version'] | urlencode }}">
</link>

<script type="text/javascript" charset="utf-8">
	var data_dependencies = [
		'all_languages',
		'language',
		'frequency_data',
		'heat_data',
		'class_data',
		'current_heat',
		'result_data',
	];

	rotorhazard.show_messages = false;



	$(document).ready(function () {

		let pilotList = {};
		let frequency_data;
		let heat_data;
		let class_data;
		let result_data;
		let streamheat;
		let streamclass;
		let rounds = [];

		//heat generation state
		let heatsCreated = 0;
		let generatingHeat = false;
		let newRoundData;
		let createdHeatIDs = [];

		// set admin flag
		rotorhazard.admin = true;
		rotorhazard.saveData();

		if (location.pathname.indexOf('/heatgenerator') >= 0) {
			$('#generator_controls').show();
			$('#scoreTable').css('overflow', 'auto');
		}
		else {
			$('#generator_controls').remove();
		}

		function heatsForRound(class_id) {
			const heatIds = [];
			for (let heat_id in heat_data.heats) {
				if (heat_data.heats[heat_id].class_id == class_id) {
					heatIds.push(heat_id);
				}
			}
			return heatIds;
		}

		function nodesForRound(class_id) {
			const heatIds = heatsForRound(class_id);
			const pilotNodes = {};
			heatIds.forEach(heatId => {
				const heat = heat_data.heats[heatId];
				heat.pilots.forEach((pilot_id, node) => {
					pilotNodes[pilot_id] = node;
				});
			});
			return pilotNodes;
		}

		function getNodeForRound(class_id, pilot_id) {
			const pilotNodes = nodesForRound(class_id);
			const node = pilotNodes[pilot_id];
			// console.log(`node for ${pilot_id} in round ${class_id}`, node);
			return node === undefined ? -1 : node;
		}

		function clearPilotTotals() {
			for (let key in pilotList) {
				pilotList[key].points = 0;
			}
		}

		function getMaxLaps(classId) {
			const { classes, formats } = class_data;
			const cls = classes.find(({ id }) => id == classId);
			const format = formats.find(({ id }) => id == cls?.format);
			const maxLaps = format?.win_condition == 2 ? format.number_laps_win : 0;
			console.log('Max Laps', maxLaps, cls?.name, class_data);
			return maxLaps;
		}

		function getRoundResults(classId, maxLaps) {
			const { heats, heats_by_class } = result_data;
			// grab heat result details for this round for heats that have been run.
			const heatResults = heats_by_class[classId]?.map(id => heats[id]).filter(heat => heat) || [];

			// pull out a list of pilots and their lap details for their (first) heat in this round
			const pilotDetails = [];
			heatResults.forEach(({ rounds }) => {
				// there really only should be a single round but if there are more than one,
				// choose the first round that has some non-deleted laps.
				const roundsWithLaps = rounds.length <= 1 ? rounds : rounds.filter(round => {
					const nodes = round.nodes.filter(node => {
						const laps = node.laps.filter(lap => !lap.deleted) || [];
						return laps.length > 0;
					}) || [];
					return nodes.length > 0;
				});
				const round = roundsWithLaps[0];
				round?.nodes?.forEach(nodeData => pilotDetails.push(nodeData));
			});

			// Normalize the data to only use the first n laps
			// (the leaderboard doesn't actually limit laps)
			const pilotResults = pilotDetails.map(details => {
				const laps = details.laps.filter(lap => !lap.deleted).slice(0, maxLaps + 1);
				const heatTime = laps.length > 0
					? laps[laps.length - 1].lap_time_stamp // - laps[0].lap_time_stamp
					: 0.0;
				return {
					...details,
					laps: Math.max(laps.length - 1, 0),
					heatTime,
					points: 0,
				}
			}).sort((a, b) => {
				if (a.laps !== b.laps) {
					return b.laps - a.laps;
				}
				return (a.heatTime - b.heatTime);
			});

			// assign points
			pilotsWithStarts = pilotResults.filter(({ heatTime }) => heatTime > 0);
			pilotsWithStarts.forEach((p, index) => {
				p.points = pilotsWithStarts.length - index
			});

			console.log('Heat results', classId, maxLaps, heatResults, pilotDetails, pilotResults);
			return pilotResults
		}

		function getLeaderboardResults(round) {
			const pilotHeats = round?.leaderboard?.by_race_time || [];
			const pilots = pilotHeats.map(
				({
					pilot_id,
					callsign,
					total_time_raw: heatTime,
					laps,
				}, index) => {
					const points = pilotHeats.length - index;
					return {
						pilot_id,
						callsign,
						heatTime,
						laps,
						points,
					};
				}
			);
			return pilots;
		}

		function calculateRoundPoints() {

			rounds = [];
			clearPilotTotals();

			if (!result_data) return;

			const { classes } = result_data;

			for (let classId in classes) {
				const maxLaps = getMaxLaps(classId);
				const round = classes[classId];
				// Only include rounds that start with "Round"
				if (round?.name.indexOf('Round') !== 0) break;
				const pilots = maxLaps > 0
					? getRoundResults(classId, maxLaps)
					: getLeaderboardResults(round);

				// total up points and add missing pilots
				if (pilots.length > 0) {
					const pilotsInThisRound = {};
					pilots.forEach(({ pilot_id, points }) => {
						if (pilot_id > 0) {
							pilotsInThisRound[pilot_id] = true;
							pilotList[pilot_id].points += points;
						}
					});

					for (let pilot_id in pilotList) {
						if (!pilotsInThisRound[pilot_id]) {
							pilots.push({
								...pilotList[pilot_id],
								heatTime: 'dnf',
								laps: 0,
								points: 0,
							});
						}
					}
					rounds.push({ pilots, name: round.name, id: round.id });
				}
			}

			console.log('-- rounds', rounds, pilotList);
		}

		function updateSLTable() {
			if (!heat_data) return;

			const currentNodes = nodesForRound(streamclass);
			const prevNodes = nodesForRound(streamclass - 1);

			//clear the dom
			const $table = $('#scoreTable').empty();

			console.log('table rounds', rounds);
			const headers = [
				"Ch",
				"Rank",
				"Pilot",
				...rounds.map(r => r.name),
				"Total",
			];

			const $headerRow = $("<tr>").appendTo($table);
			headers.forEach(label => {
				$(`<th>`).text(label).appendTo($headerRow);
			});

			const pilotRank = Object.values(pilotList).sort((a, b) => b.points - a.points);
			pilotRank.forEach((pilot, index) => {
				const $row = $("<tr>").appendTo($table);
				const node = currentNodes[pilot.pilot_id];
				const prevNode = prevNodes[pilot.pilot_id];
				const changed = streamclass > 1 && node != prevNode;
				const channels = frequency_data?.fdata?.map(({ band, channel }) => `${band}${channel}`) || [];
				$('<td>').text(`${channels[node] || '--'}${changed ? '!' : ''}`).appendTo($row);
				$('<td>').text(`#${index + 1}`).appendTo($row);
				$('<td>').text(pilot.callsign).appendTo($row);
				rounds.forEach(round => {
					const pilotRound = round.pilots.find(
						({ pilot_id }) => pilot.pilot_id == pilot_id);
					$('<td>').text(pilotRound?.points || '0').appendTo($row);
				});
				$('<td>').text(pilot.points).appendTo($row);
			});
		}

		function updateClassSelectors(classes) {
			const $select = $('#generator_output_class');
			const output_val = $select.val();

			$select.empty().append($('<option value="0">').text(__('Unclassified')));

			const options = classes.map(({ name, id }) => {
				const label = `${__('Class')} ${id}`;
				return $(`<option value="${id}">`).text(name ? `${name} (${label})` : label);
			});
			$select.append(options);

			if ($('#generator_output_class option[value="' + output_val + '"]').length) {
				$select.val(output_val);
			}
		}

		$('#generator_output_class').change(() => {
			const class_id = $('#generator_output_class').val();
			const round = class_data?.classes?.find(({ id }) => id == class_id);
			if (round?.name) {
				$('#generate_round_class').val(`${round.name} - Heat`);
			}
		});

		socket.on('class_data', function (msg) {
			console.log("class data", msg);
			class_data = msg;
			updateClassSelectors(msg.classes);
		});

		function getNewHeat(heatData, excludedIDs) {
			for (let key in heatData) {
				const heat = heatData[key];
				if (heat['note'] == null) {
					if (heat['locked'] == false) {
						if (excludedIDs.includes(heat['heat_id']) == false) {
							console.log("found new heat!");
							return heat['heat_id']
						}
					}
				}
			}
			return undefined;
		}

		function populateNewHeats(msg) {
			if (generatingHeat) {
				if (heatsCreated < newRoundData.length) {
					heatsCreated += 1;
					console.log("editing heat " + heatsCreated);
					console.log(newRoundData);
					var newHeat = newRoundData[heatsCreated - 1]
					for (var node in newHeat['heat']) {
						console.log(newHeat);
						var pilot_id = newHeat['heat'][node];
						var newNote = newHeat['note'];
						var newHeatID = getNewHeat(msg.heats, createdHeatIDs);

						if (newHeatID == undefined) {
							heatsCreated -= 1;
							break;
						} else {
							var heatEditData = {
								heat: parseInt(newHeatID),
								node: parseInt(node),
								note: newNote,
								class: parseInt($('#generator_output_class').val()),
								pilot: parseInt(pilot_id)
							};
							console.log(heatEditData);
							socket.emit('alter_heat', heatEditData);
						}

					}
					createdHeatIDs.push(newHeatID);
				} else {
					generatingHeat = false;
					heatsCreated = 0;
					newRoundData = undefined;
					createdHeatIDs = [];
					console.log("done generating heats");
				}
			}
		}

		function addGeneratedHeat() {
			generatingHeat = true;
			heatsCreated = 0;
			//socket.emit('add_race_class');
			for (let i = 0; i < newRoundData.length; i++) {
				console.log("adding heat " + i);
				socket.emit('add_heat');
			}
			generatingHeat = true;
		}

		function assignNode(newHeatPilots) {
			// map pilots to their previous node if possible.
			// if not possible assign them to the first unused node
			const newNodeMap = {};
			const conflicts = [];
			newHeatPilots.forEach(({ pilot_id, prevNode }) => {
				if (prevNode >= 0 && !newNodeMap.hasOwnProperty(prevNode)) {
					newNodeMap[prevNode] = pilot_id;
				}
				else {
					conflicts.push(pilot_id);
				}
			});
			conflicts.forEach(pilot_id => {
				for (let node = 0; ; node += 1) {
					if (!newNodeMap.hasOwnProperty(node)) {
						newNodeMap[node] = pilot_id;
						break;
					}
				}
			});
			return newNodeMap;
		}

		$('button#generate_heats').click(function (event) {
			const heatPrefix = $('#generate_round_class').val().trim() + " ";
			const prevClass = Math.max(1, parseInt($('#generator_output_class').val()) - 1);
			const pilotsPerHeat = parseInt($('#pilotsPerHeat').val());
			console.log("pilots per heat: ", pilotsPerHeat);
			let node = 0;
			let heatNumber = 0;
			const reverseOrder = true;
			let newHeatPilots = [];
			newRoundData = [];
			const pilotRank = Object.values(pilotList).sort((a, b) => b.points - a.points);
			pilotRank.forEach((pilot, index) => {
				const { points, pilot_id, callsign } = pilot;
				console.log(`${pilot_id}: ${points} (${callsign})`);
				newHeatPilots.push({
					pilot_id,
					prevNode: getNodeForRound(prevClass, pilot_id),
				});
				node += 1;
				if ((node == pilotsPerHeat) || (pilotRank.length - 1 == index)) {
					console.log(newHeatPilots);
					const heatName = heatPrefix + String.fromCharCode(65 + heatNumber);
					heatNumber += 1;
					node = 0;
					newRoundData.push({ "heat": assignNode(newHeatPilots), "note": heatName });
					console.log("pushing round data ", newRoundData[newRoundData.length - 1]);
					newHeatPilots = [];
				}
			});
			console.log(newRoundData);
			if (reverseOrder) {
				newRoundData.reverse();
			}
			addGeneratedHeat();
		});

		socket.on('result_data', function (msg) {
			console.log("result data", msg);
			result_data = msg;
			calculateRoundPoints();
			updateSLTable();
		});

		socket.on('frequency_data', function (msg) {
			console.log('frequency_data', msg);
			frequency_data = msg;
			updateSLTable();
		});

		socket.on('heat_data', function (msg) {
			console.log('heat_data', msg);
			heat_data = msg;
			pilotList = {};
			for (let key in msg.heats) {
				//console.log('-- heat', msg.heats[key]);
				msg.heats[key].pilots.forEach((pilotId) => {
					if (pilotId) {
						pilotList[pilotId] = {
							points: 0,
							...msg.pilot_data.find(({ pilot_id }) => pilot_id === pilotId),
						};
					}
				});
			}
			console.log('flying pilots', pilotList);
			calculateRoundPoints();
			updateSLTable();

			populateNewHeats(msg);
		});

		socket.on('current_heat', function (msg) {
			console.log('current_heat', msg);
			streamheat = msg.current_heat;
			streamclass = msg.heat_class;
			// heat changed so redisplay (channels may be different)
			updateSLTable();
		});

	});

</script>
{% endblock %} {% block content %}
<table class="scoreTable" id="scoreTable" style="overflow: hidden;">
</table>
<div id="generator_controls" style="display: none;">
	<p>
		<label for="generator_output_class">Round Class</label><br>
		<select id="generator_output_class">
			<option>{{ __('Loading...') }}</option>
		</select>
	</p>
	<p>
		<label for="generate_round_class">Round - Heat Name</label><br>
		<input type="text" id="generate_round_class" value="Round X - Heat">
	</p>
	<p>
		<label for="pilotsPerHeat">Pilots Per Heat</label><br>
		<input type="number" id="pilotsPerHeat" value="4">
	</p>
	<p>
		<button id=generate_heats>Generate Heats</button>
	</p>
</div>
{% endblock %}