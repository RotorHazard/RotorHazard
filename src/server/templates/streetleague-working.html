 {% extends "layout-basic.html" %} {% block title %}{% endblock %} {% block head %}
<link rel="stylesheet" href="/static/streetleague.css?{{ serverInfo['release_version'] | urlencode }}"></link>

<script type="text/javascript" charset="utf-8">
	var data_dependencies = [
		'all_languages',
		'language',
		'exporter_list',
	];

	$(document).ready(function () {
		var heartbeatCounter = 0;
		var pilotCount = 0;
		var pilots;
		var pilotRaceTotalPoints;
		var heats;
		socket.emit('load_data', {'load_types': [
			'heat_data',
			'pilot_data',
		]});

		// set admin flag
		rotorhazard.admin = true;
		rotorhazard.saveData();
		$('nav li').removeClass('admin-hide');

		socket.on('exporter_list', function (msg) {
			$('#exporter_list').empty();
			if ('exporters' in msg && msg.exporters.length) {
				msg.exporters.sort(function(a, b){return ('' + a.label).localeCompare(b.label)})
				for (idx in msg.exporters) {
					var ex = msg.exporters[idx];
					$('#exporter_list').append('<option value="' + ex.name + '">' + __(ex.label) + '</option>');
				}
				$('#exporter_list').prop('disabled', false);
				$('#export_database').prop('disabled', false);
			} else {
				$('#exporter_list').append('<option value="-">' + __('No Exporters') + '</option>');
				$('#exporter_list').prop('disabled', true);
				$('#export_database').prop('disabled', true);
			}
		});

		function calculateRoundPoints(raceResults){
		        var SLRounds = {};
		        var raceClasses = raceResults["classes"];
						for (var key in raceClasses) {
							var roundNumber = raceClasses[key];
							var pilotHeats = roundNumber['leaderboard']['by_race_time'];
							var points = pilotHeats.length;
							SLRounds[key] = []; //{"1":[{"callsign":"Vanover","points":32,"laps":3,"heatTime":123}],"2":[],"3":[]}
							for(var pilotHeatKey in pilotHeats){
								var pilotHeat = pilotHeats[pilotHeatKey];
								var callsign = pilotHeat['callsign'];
								var pilot_id = pilotHeat['pilot_id'];
								var heatTime = pilotHeat['total_time_raw'];
								var laps = pilotHeat['laps'];
								var pilotID = pilotHeat['pilot_id'];
								SLRounds[key].push({"pilot_id":pilot_id,"callsign":String(callsign),"points":String(points),"laps":String(laps),"heatTime":String(heatTime)});
								points -= 1;
							}
						}
						//CAN'T FIGURE OUT HOW TO DO JAVASCRIPT JSON SHIT....
		        return SLRounds;
		}

		function getPilotPointsByRound(rounds){
			var pilotPoints = {};

			//Let's get a list of pilots who have scored points
			var scoringPilots = [];
			var roundNumber = 0;
			for (var roundKey in rounds) {
				var round = rounds[roundKey];
				roundNumber+=1;
				for (var i = 0; i < round.length; i++) {
					var pilotHeat = round[i];
					var pilot_id = pilotHeat['pilot_id'];
					if(scoringPilots.includes(callsign)){
					}else{
						scoringPilots.push(callsign);
					}
				}
			}

			for (var roundKey in rounds) {
				var round = rounds[roundKey];
				var pilotsInThisRound = [];
				for (var i = 0; i < round.length; i++) {
					var pilotHeat = round[i];
					var pilot_id = pilotHeat['pilot_id'];
					pilotsInThisRound.push(pilot_id);
				}
				//this gets a list of pilots who never made a wholeshot in this round
				let missingPilots = scoringPilots.filter(x => !pilotsInThisRound.includes(x));
				for (var k = 0; k < missingPilots.length; k++) {
					var missingPilotCallsign = missingPilots[k];
					round.push({"pilot_id": pilot_id, callsign: missingPilotCallsign, points: '0', laps: '0', heatTime: 'dnf'})
				}
			}

			//create a list of pilots containing the points they earned in each round

			for (var roundKey in rounds) {
				var round = rounds[roundKey];
				for (var i = 0; i < round.length; i++) {
					var pilotHeat = round[i];
					var callsign = pilotHeat['callsign'];
					var pilot_id = pilotHeat['pilot_id'];
					var pilotRoundPoints = Number(pilotHeat['points']);
					if(callsign in pilotPoints){
						pilotPoints[callsign].push({'pilot_id':pilot_id, 'points':pilotRoundPoints});
					}else{
						pilotPoints[callsign] = [{'pilot_id':pilot_id, 'points':pilotRoundPoints}];
					}
				}
			}

			return pilotPoints;
		}

		function getPilotTotalsFromRounds(pilotPoints){
			//create a list of pilots and their total points
			var pilotTotalPoints = [];
			for (var callsign in pilotPoints) {
				var pilotPointsRounds = pilotPoints[callsign];
				var pilot_id = pilotPoints['pilot_id'];
				var totalPoints = 0;
				for (var i = 0; i < pilotPointsRounds.length; i++) {
					totalPoints += pilotPointsRounds[i]['points'];
				}
				var pilotJSON = {'pilot_id': pilot_id, 'callsign': callsign, "points": Number(totalPoints)};
				pilotTotalPoints.push(pilotJSON);
			}

			//sort the list
			pilotTotalPoints.sort((a,b) => b.points - a.points);
	    return pilotTotalPoints;
		}

		function slformat(raceResults){
		        var rounds = calculateRoundPoints(raceResults);
						var pilotPointsByRound = getPilotPointsByRound(rounds);
						pilotRaceTotalPoints = getPilotTotalsFromRounds(pilotPointsByRound);
						console.log(pilotRaceTotalPoints);
						createSLTable(pilotPointsByRound, pilotRaceTotalPoints);

		}

		function getPilotTotal(callsign, raceData){
			for (var i = 0; i < raceData.length; i++) {
				var pilotData = raceData[i];
				if(pilotData['callsign'].localeCompare(callsign)==0){
					return pilotData;
				}
			}
		}

		function createSLTable(roundData, raceData){
			var headers = ["Round 1", "Round 2", "Round 3", "Round 4", "Round 5", "Round 6"];
			var table = document.getElementsByClassName('scoreTable')[0];
			var headerRow = document.createElement("tr");
			for (var rowIndex = -2; rowIndex < roundData[raceData[0]['callsign']].length+1; rowIndex++) {
				if(rowIndex==-2){
					var cell = document.createElement("th");
					cell.innerHTML = "Rank";
					headerRow.appendChild(cell);
				}else if(rowIndex==-1){
					var cell = document.createElement("th");
					cell.innerHTML = "Pilot";
					headerRow.appendChild(cell);
				}else if(rowIndex==roundData[raceData[0]['callsign']].length){
					var cell = document.createElement("th");
					cell.innerHTML = "Total";
					headerRow.appendChild(cell);
				}else{
					var cell = document.createElement("th");
					cell.innerHTML = "Round "+(rowIndex+1);
					headerRow.appendChild(cell);
				}
			}

			table.appendChild(headerRow);
			var rank = 1;
			for (var i = 0; i < raceData.length; i++) {
				var callsign = raceData[i]['callsign'];
				var row = document.createElement("tr");
				for (var rowIndex = -2; rowIndex < roundData[callsign].length+1; rowIndex++) {
					var roundNumber = rowIndex;
					if(rowIndex==-2){
						cell = document.createElement("td");
						cell.innerHTML = "#"+rank;
						row.appendChild(cell);
						rank+=1;
					}else if(roundNumber<0){
						cell = document.createElement("td");
						cell.innerHTML = callsign;
						row.appendChild(cell);
					}else if(roundNumber==roundData[callsign].length){
						cell = document.createElement("td");
						cell.innerHTML = getPilotTotal(callsign,raceData)['points'];
						row.appendChild(cell);
					}else{
						cell = document.createElement("td");
						cell.innerHTML = roundData[callsign][roundNumber]['points'];
						row.appendChild(cell);
					}
				}
				table.appendChild(row);

			}
		}

		$('.sortButton').click(sortTable);

		function sortTable(n) {
			var n = Number(document.getElementById("quantity").value);
			if(n==0){
				console.log("n="+n);
				n=7;
			}
			n+=1;
		  var table, rows, switching, i, x, y, shouldSwitch, dir, switchcount = 0;
		  table = document.getElementsByClassName("scoreTable")[0];
		  switching = true;
		  // Set the sorting direction to ascending:
		  dir = "desc";
		  /* Make a loop that will continue until
		  no switching has been done: */
		  while (switching) {
		    // Start by saying: no switching is done:
		    switching = false;
		    rows = table.rows;
		    /* Loop through all table rows (except the
		    first, which contains table headers): */
		    for (i = 1; i < (rows.length - 1); i++) {
		      // Start by saying there should be no switching:
		      shouldSwitch = false;
		      /* Get the two elements you want to compare,
		      one from current row and one from the next: */
		      x = rows[i].getElementsByTagName("TD")[n];
		      y = rows[i + 1].getElementsByTagName("TD")[n];
		      /* Check if the two rows should switch place,
		      based on the direction, asc or desc: */
		      if (dir == "asc") {
		        if (x.innerHTML.toLowerCase() > y.innerHTML.toLowerCase()) {
		          // If so, mark as a switch and break the loop:
		          shouldSwitch = true;
		          break;
		        }
		      } else if (dir == "desc") {
		        if (Number(x.innerHTML.toLowerCase()) < Number(y.innerHTML.toLowerCase())) {
		          // If so, mark as a switch and break the loop:
		          shouldSwitch = true;
		          break;
		        }
		      }
		    }
		    if (shouldSwitch) {
		      /* If a switch has been marked, make the switch
		      and mark that a switch has been done: */
		      rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
		      switching = true;
		      // Each time a switch is done, increase this count by 1:
		      switchcount ++;
		    } else {
		      /* If no switching has been done AND the direction is "asc",
		      set the direction to "desc" and run the while loop again. */
		      if (switchcount == 0 && dir == "asc") {
		        dir = "desc";
		        switching = true;
		      }
		    }
		  }
		}

		socket.on('pilot_data', function (msg) {
			pilotCount = msg.pilots.length;
			pilots = msg.pilots;
			console.log("pilots")
			console.log(pilots);
		});

		socket.on('heat_data', function (msg) {
			heats = msg.heats;
			console.log("heatdata");
			console.log(heats);
		});

		$('button#generate_heats').click(function (event) {
			socket.emit('add_race_class');
			var heatPrefix = "test heat ";
			var currentHeatNumber = 0;
			var node = 0;
			for (var i = 0; i < pilotRaceTotalPoints.length; i++) {
				var totalPoints = pilotRaceTotalPoints[i]['points'];
				console.log("i = "+i);
				console.log(pilotRaceTotalPoints[i]);
			}
			var data = {
				heat: parseInt($(this).data('heat')),
				node: parseInt(node),
				pilot: parseInt($(this).val())
			};
			//socket.emit('alter_heat', data);
			return false;
		});

		socket.on('result_data', function(msg){
			location.reload();
		});

		socket.on('exported_data', function (msg) {
			var data = msg.data
			/*
			msgArray = atob(msg.file_data);  // decode Base64 string
			// convert decoded data to byte array
			var byteNumbers = new Array(msgArray.length);
			for (var i = 0; i < msgArray.length; i++) {
				byteNumbers[i] = msgArray.charCodeAt(i);
			}
			var byteArray = new Uint8Array(byteNumbers);
			*/
			// construct blob and initiate browser save-as
			//console.log(data);
			slFormatData = slformat(JSON.parse(data));
			//createSLTable(slFormatData);
			//saveAs(new Blob([data], {type: msg.encoding}), msg.filename);
		});

		var exportData = {exporter: 'json_complete_results'};
		socket.emit('export_database', exportData);

		var generateRound
	});
</script>
{% endblock %} {% block content %}
<table class="scoreTable" id="scoreTable" style="overflow: hidden;">
</table>
<!--<p>
<button class="sortButton">Sort</button>
	<label for="quantity">Round Number to Sort (0=total)</label>
	<input type="number" id="quantity" name="quantity" min="1" max="10" value="0">
</p>
-->
<p>
	<label for="generate_round_class">Round class name:</label><br>
	<input type="text" id="generate_round_class">
	<button id=generate_heats>Generate Heats</button>
	<button id=configure_round>Configure Round</button>
</p>



{% endblock %}
